# -*- coding: utf-8 -*-
"""Task6_Smirnov.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dcgZwDO_eQtghnX9qQguiTBQ-W-huVO7
"""

import numpy as np

#initial conditions
class IC:
    def __init__(self, I = 101, CFL = 0.5, lamb = 0):
        #lambda
        self.lamb = lamb
        #time period of modeling
        self.T = 0.5
        #space bounds
        self.limits = [0, 2]
        #domain of function
        self.a = 0.5
        self.b = 1.5
        #speed
        self.c = 1
        #nodes and steps
        self.I = I #space
        self.h = abs(self.limits[0] - self.limits[1]) / (self.I - 1)
        self.CFL = CFL
        self.t = self.CFL * self.h / self.c
        self.N = int(self.T // self.t) #time
    #init condition
    def ic(self, i):
        x = self.limits[0] + self.h * (i - 0.5)
        k = - self.a - self.b + 2 * x
        g = 1 / ((self.b - self.a)**2 - k**2)
        if x > self.a and x < self.b:
            rez = np.exp(- 4 * k**2 * g)
        else:
            rez = 0
        return rez
    #support functions
    def s_1 (self, i):
        x = self.limits[0] + self.h * (i - 0.5)
        tmp = self.b - self.a
        rez =  -1 * ((2 * x - (self.a + self.b)) * tmp ** 2) / (((x - self.a) * (x - self.b)) ** 2)
        return rez

    def s_2 (self, i):
        x = self.limits[0] + self.h * (i - 0.5)
        tmp = self.b - self.a
        rez = -2 * (tmp ** 2) / (((x - self.a) * (x - self.b)) ** 3) * ((x - self.a) * (x - self.b) -  1 * (2 * x - (self.a + self.b)) ** 2)
        return rez
    
    #second x-derivative from ic
    def sd(self, i):
        x = self.limits[0] + self.h * (i - 0.5)
        if x > self. a and x < self.b:
            dim = self.ic(i) * self.s_1(i) ** 2 + self.ic(i) * self.s_2(i)
            rez = dim * self.c**2
        else:
            rez = 0
        return rez
    #second time step
    def ts(self, i):
        rez = self.ic(i) + (self.t**2) * self.sd(i) * 0.5
        return rez

class Data:
    def __init__(self, IC):
        self.IC = IC
        self.data = np.zeros((self.IC.N, self.IC.I))
        self.make_ic()
        for n in range(2, len(self.data)):
            for i in range(1, self.IC.I - 1):
                self.data[n][i] = self.make_value(i, n)
                #boundary conditions
                self.data[n][0] = 0
                self.data[n][-1] = self.data[n][-2]
        
    def make_ic(self):
        for i in range(1, len(self.data[0])):
            self.data[0][i] = self.IC.ic(i)
            self.data[0][0] = 0
            self.data[0][-1] = self.data[0][-2]
        for i in range(1, len(self.data[0])):
            self.data[1][i] = self.IC.ts(i)
            self.data[1][0] = 0
            self.data[1][-1] = self.data[1][-2]
          
    def make_value(self, i, n):
        x = self.IC.limits[0] + self.IC.h * (i - 0.5) 
        tmp1 = 2 * self.data[n - 1][i] - self.data[n - 2][i]
        tmp2 = (self.IC.t * self.IC.c / self.IC.h)**2
        tmp3 = self.data[n - 1][i + 1] - 2 * self.data[n - 1][i] + self.data[n - 1][i - 1]
        tmp4 = 1 + (self.IC.lamb * self.IC.c * self.IC.t)**2
        rez =(tmp1 + tmp2 * tmp3) / tmp4 
        return rez

import matplotlib.pyplot as plt
w_1 = Data(IC())
print('First grid done: ', 'h:', "%.4f"%(w_1.IC.h), 'I:', "%.4f"%(len(w_1.data[0])), 'N:', "%.4f"%(len(w_1.data)))

x_1 = np.linspace(w_1.IC.limits[0] + 0.5 * w_1.IC.h, w_1.IC.limits[1] - 0.5 * w_1.IC.h, w_1.IC.I)
print(len(x_1), len(w_1.data[0]))
for n in range(len(w_1.data)//10):
    plt.plot(x_1, w_1.data[n * 10])
    plt.legend()
    plt.grid(True)
    plt.pause(0.1)